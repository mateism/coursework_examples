---
title: "Assignment 1 - Data wrangling and functions"
author: "Simon Marcell Matei - mateism"
date: "`r format(Sys.time(), '%B %d, %Y | %H:%M:%S | %Z')`"
output:
  html_document:
    code_folding: show
    df_print: paged
    highlight: tango
    number_sections: no
    theme: cosmo
    toc: no
---

```{=html}
<style>
div.answer {background-color:#f3f0ff; border-radius: 5px; padding: 20px;}
div.comment {background-color:#F0F6FF; border-radius: 5px; padding: 20px;}

</style>
```

```{=html}
<style>
div.gradingadvice {background-color:#a2bc89; border-radius: 5px; padding: 20px;}
</style>
```

```{=html}
<style>
div.examplefeedback {background-color:#FFA500; border-radius: 5px; padding: 20px;}
</style>
```

```{=html}
<style>
div.lookfor {background-color:#a389bc; border-radius: 5px; padding: 20px;}
</style>
```

```{r, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      eval = TRUE,
                      error = FALSE,
                      message = FALSE,
                      warning = FALSE,
                      comment = NA)
```

<!-- Do not forget to input your Github username in the YAML configuration up there -->

------------------------------------------------------------------------

```{r, include = T}
library(tidyverse)
```

<br>

## Task 1: Getting started with the Astronaut Database

The data this week comes from [Mariya Stavnichuk and Tatsuya Corlett](https://data.mendeley.com/datasets/86tsnnbv2w/1).

This [article](https://www.sciencedirect.com/science/article/abs/pii/S2214552420300444) talks about the data set in greater detail.

> This database contains publically available information about all astronauts who participated in space missions before 15 January 2020 collected from NASA, Roscosmos, and fun-made websites. The provided information includes full astronaut name, sex, date of birth, nationality, military status, a title and year of a selection program, and information about each mission completed by a particular astronaut such as a year, ascend and descend shuttle names, mission and extravehicular activity (EVAs) durations.

Credit for preparing the data set: [Georgios Karamanis](https://twitter.com/geokaramanis)

You can use the data set directly by importing the csv file in the repository.

------------------------------------------------------------------------

If not noted otherwise, for the following tasks, you will work only with a subset of astronauts based on their **year of birth**. The year span you are assigned depends on your first name:

| Your first name starts with... | Years of birth    |
|--------------------------------|-------------------|
| A-I                            | (1921-1942]       |
| J-R                            | (1943-1964]       |
| ***S-Z***                      | ***(1965-1983]*** |

<br>

------------------------------------------------------------------------

```{r}
astronauts <- read_csv("astronauts.csv")
#subsetting dataset according to above instruction based on first name
astronauts_own <- astronauts |> 
  filter(year_of_birth >= 1965) #upper bound not needed since max(astronauts$year_of_birth) = 1983
```

a)  How many unique astronauts were there in the full data set and how many are there in your subset? (*Note that some might have been part of multiple missions.*)

```{r}
print("Nr. of astronauts in the full dataset:")
astronauts |> 
  distinct(name) |> 
  count() |> 
  as.numeric()
print("Double checking that counting based on distinct names gives correct result (as multiple different astronauts could have the same name theoretically):")
astronauts |> 
  distinct(number) |> 
  count() |> 
  as.numeric()
print("Nr. of unique astronauts in my subset:")
astronauts_own |> 
  distinct(name) |> 
  count() |> 
  as.numeric()
print("Double checking again:")
astronauts_own |> 
  distinct(number) |> 
  count() |> 
  as.numeric()
```

b)  What's the overall share of female astronauts in the subset of data you were assigned to? And what's the share of astronauts with U.S. nationality?

```{r}
astronauts_own |> 
  distinct(name, .keep_all = TRUE)|> 
  summarise(
    n_total = n(),
    n_female = sum(sex == "female"),
    prop_female = n_female / n_total,
    n_us = sum(nationality == "U.S."),
    prop_us = n_us / n_total
  )
```

<br>

c)  Create a new data set `total_hours_df` containing the unique names and the total duration of all missions in hours (`total_hrs_sum`) for each astronaut in the subset. Then, visualize the distribution of that variable using an appropriate plot type.

```{r}
total_hours_df <- astronauts_own |>
  group_by(name) |>
  mutate(total_hrs_sum = sum(hours_mission)) |>
  ungroup() |>
  select(name, total_hrs_sum) |> 
  distinct()

ggplot(total_hours_df, aes(x = total_hrs_sum)) +
  geom_histogram(binwidth = 250, boundary = 0, colour = "black", fill = "grey") +
  labs(
    title = "Distribution of total mission hours of astronauts (born 1965-1983)",
    subtitle = "(Bins in 250 hour increments)",
    x = "Total duration of all missions (hours)", 
    y = "Count"
    ) +
  scale_x_continuous(breaks = seq(0, 15000, by = 1000)) +
  scale_y_continuous(breaks = seq(0, 20, by = 2))
```

<br>

d)  Using the full data set, provide a plot that shows the overall share of *civilian* astronauts by the year of mission!

```{r}
civ_prop_df <- astronauts |>
  group_by(year_of_mission) |>
  summarise(
    n = n(),
    n_civilian = sum(military_civilian == "civilian"),
    prop_civilian = n_civilian / n,
    pct_civilian = prop_civilian * 100
  )

ggplot(civ_prop_df, aes(x = year_of_mission, y = pct_civilian)) +
  geom_jitter(width = 0) +
  geom_line(alpha = 0.25) +
  labs(
    title = "Share of civillian astronauts by year",
    x = "Year", 
    y = "Percentage of civilians"
    ) +
  scale_x_continuous(breaks = seq(1960, 2020, by = 4)) +
  scale_y_continuous(breaks = seq(0, 100, by = 5))
```

<br>

------------------------------------------------------------------------

### Task 2 ‚Äì Silly Password Strength Checker

Program a function `check_password(pw)` that takes a password string `pw` and returns a funny *strength rating* according to the following rules:

1.  If the password contains the word `"password"` (in any mix of upper/lower case), return `"Terrible! üö´"`.\
2.  If the password is shorter than 6 characters, return `"Too weak üí§"`.\
3.  If it contains only letters, return `"Meh üòê"`.\
4.  If it contains letters **and** numbers, return `"Better üëç"`.\
5.  If it contains letters **and** numbers **and** at least one special character from `!@#$%^&*?`, return `"Strong üí™"`.

Write the function and test it with at least **five different passwords** that trigger different outputs. Also, use functions from the `stringr` package to execute the checks in your function (hint: look up `str_detect()` and `str_length()`).

```{r}
check_password <- function(pw){
  if(!is.character(pw)) {
    stop("Password has to be string")
    } else if(str_detect(pw, regex("password", ignore_case = TRUE))) {
      return("Terrible! üö´")
    } else if(str_length(pw) < 6){
      return("Too weak üí§")
    } else if(str_detect(pw, "^[[:alpha:]]+$")){
      return("Meh üòê")
    } else if(str_detect(pw, "^[[:alnum:]]+$")){
      return("Better üëç")
    } else if(str_detect(pw,"[[:alpha:]]") & str_detect(pw,"[[:digit:]]") & str_detect(pw, "[!@#$%^&*?]")) {
      return("Strong üí™")
  }
}

pw_1 <- "first_pAssWOrd1"
check_password(pw_1)

pw_2 <- "ab&12"
check_password(pw_2)

pw_3 <- "OnlyLetters"
check_password(pw_3)

pw_4 <- "LettersAnd12345"
check_password(pw_4)

pw_5 <- "leTtErS&numb3r$"
check_password(pw_5)
```

<br>

------------------------------------------------------------------------

### Task 3 - The Monty Hall Machine

a)  Write an R function that simulates the [Monty Hall problem](https://en.wikipedia.org/wiki/Monty_Hall_problem). Start with writing a function called `monty_hall_choice()` that:

-   Simulates a single round of the Monty Hall problem.
-   Has an argument switch that controls whether the contestant switches doors after Monty reveals a goat.
-   Returns TRUE if the contestant wins the car, and FALSE if they do not. Test it by running it 10 times each with switch = TRUE and switch = FALSE, and summarize the results.

```{r}
monty_hall_choice <- function(door_switch){
  if(!is.logical(door_switch)){
    stop("door_switch argument must be a logical value")
  }
  #initial setup
  winning_door <- sample(1:3, 1)
  contestant_pick <- sample(1:3, 1)
  
  #determining which door is opened by Monty (can't be the winning door or the one picked by the contestant)
  if(winning_door == contestant_pick){
    opened_door <- sample(c(1,2,3)[-winning_door], 1)
  } else {
    opened_door <- c(1,2,3)[-c(winning_door, contestant_pick)]
  }
  #determining the door the contestant can switch to
  switch_target <- c(1,2,3)[-c(contestant_pick, opened_door)]
  
  #checking whether contestant wins:
  if(door_switch == FALSE){
    return(winning_door == contestant_pick)
    #debug:
    # return(list(
    #   winning_door == contestant_pick,
    #   "winning_door" = winning_door, 
    #   "init_pick" = contestant_pick, 
    #   "opened_door" = opened_door, 
    #   "switch_target"= switch_target))
  } else {
    return(winning_door == switch_target)
    #debug:
    # return(list(
    #   winning_door == switch_target,
    #   "winning_door" = winning_door, 
    #   "init_pick" = contestant_pick, 
    #   "opened_door" = opened_door, 
    #   "switch_target"= switch_target))
  }
}
```

```{r}
print("Number of wins in Monty Hall contest with contestant not switching 10 times:")
sum(replicate(10, monty_hall_choice(FALSE)))
print("Number of wins in Monty Hall contest with contestant switching 10 times:")
sum(replicate(10, monty_hall_choice(TRUE)))
```

<br>

b)  **Bonus challenge (not required):** Now, create a function `monty_hall_simulation()` to simulate multiple rounds of the Monty Hall problem:

-   The function should wrap around the `monty_hall_choice()`.
-   Add an argument n to the function that specifies how many rounds to simulate.
-   The function should return the proportion of times the contestant wins the car for both strategies (switch = TRUE and switch = FALSE).

```{r}
monty_hall_simulation <- function(n){
  if(!is.numeric(n) | n < 1){
    stop("n must be numeric and larger than 0")
  }
  prop_win_false <- sum(replicate(n, monty_hall_choice(FALSE))) / n
  prop_win_true <- sum(replicate(n, monty_hall_choice(TRUE))) / n
  return(list(
    "prop_win_false" = prop_win_false,
    "prop_win_true" = prop_win_true
  ))
}
```

```{r}
monty_hall_simulation(1000000)
```

<br>

c)  **Bonus challenge 2 (you're REALLY bored, right?):** Generalize the Monty Hall Problem to k doors and k-1 goats, where the host will open all doors except for 2. Now, visualize the probability of winning (proportion of wins) for both strategies (switch and stay) as a function of the number of simulated rounds n and the number of doors k, for a set of values for both n and k that you choose. *Important:* This is just for fun. You don't have to work on this task if you don't have time. Providing a right/wrong solution does not give/cost you extra points. (A right solution gives you kudos from the instructor though!)

```{r}
monty_hall_choice_k <- function(k = 3, door_switch){
  if (!is.numeric(k) | k < 3 | !is.logical(door_switch)) {
    stop("k must be a natural number not smaller than 3, and door_switch must be a logical value")
  }
  #initial setup
  winning_door <- sample(1:k, 1)
  contestant_pick <- sample(1:k, 1)
  
  #determining which door is opened by Monty (can't be the winning door or the one picked by the contestant)
  if(winning_door == contestant_pick){
    opened_door <- sample(c(1:k)[-winning_door], k - 2)
  } else {
    opened_door <-sample(c(1:k)[-c(winning_door, contestant_pick)], k - 2)
  }
  #determining the door the contestant can switch to
  switch_target <- c(1:k)[-c(contestant_pick, opened_door)]
  
  if(door_switch == FALSE){
    return(winning_door == contestant_pick)
    #debug:
    # return(list(
    #   winning_door == contestant_pick,
    #   "winning_door" = winning_door,
    #   "init_pick" = contestant_pick,
    #   "opened_door" = opened_door,
    #   "switch_target"= switch_target))
  } else {
    return(winning_door == switch_target)
    #debug:
    # return(list(
    #   winning_door == switch_target,
    #   "winning_door" = winning_door,
    #   "init_pick" = contestant_pick,
    #   "opened_door" = opened_door,
    #   "switch_target"= switch_target))
  }
}
```

```{r}
monty_hall_k_simulation <- function(k, n){
  if(!is.numeric(n) | n < 1){
    stop("n must be numeric and larger than 0")
  }
  prop_win_false <- sum(replicate(n, monty_hall_choice_k(k, FALSE))) / n
  prop_win_true <- sum(replicate(n, monty_hall_choice_k(k, TRUE))) / n
  return(list(
    "prop_win_false" = prop_win_false,
    "prop_win_true" = prop_win_true
  ))
}
```

```{r}
monty_hall_k_simulation(10, 100000)
monty_hall_k_simulation(100, 100000)
```

